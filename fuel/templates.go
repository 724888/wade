package main

import (
	"bytes"
	"text/template"
)

type (
	importTD struct {
		Path string
		Name string
	}

	preludeTD struct {
		Pkg            string
		Imports        []importTD
		DefaultImports bool
	}

	stateFieldTD struct {
		Name, Type, Path string
	}

	comMethodsTD struct {
		Receiver    string
		StateFields []stateFieldTD
	}

	refFieldTD struct {
		Name, Type string
	}

	refsTD struct {
		ComName  string
		TypeName string
		Fields   []refFieldTD
	}

	fieldAssTD struct {
		Name, Value string
	}

	comCreateTD struct {
		Decls            *bytes.Buffer
		ComName, ComType string
		FieldsAss        []fieldAssTD

		ChildrenCode []*bytes.Buffer
	}

	comDefTD struct {
		ComName string
	}

	renderFuncTD struct {
		ComName string
		Return  *bytes.Buffer
		Decls   *bytes.Buffer
	}

	elementVDOMTD struct {
		Tag      string
		Key      string
		Attrs    map[string]string
		Children []*bytes.Buffer
	}

	textNodeVDOMTD struct {
		Text string
	}
)

const (
	childrenVDOMCode = `[[if .]]vdom.NewNodeList(
	[[$last := lastIdx .]]
	[[range $i, $c := .]]
	[[$c]][[if lt $i $last]],[[end]][[end]])[[else]]nil[[end]]`

	textNodeVDOMCode = `vdom.NewTextNode([[.Text]])`

	elementVDOMCode = `[[define "attrs"]]` +
		`[[if .Attrs]]` +
		`vdom.Attributes{` +
		`[[range $key, $value := .Attrs]]
			"[[$key]]": [[$value]],
		[[end]]` +
		`}[[else]]nil[[end]]` +
		`[[end]]` +
		`vdom.NewElement("[[.Tag]]", [[.Key]], [[template "attrs" .]],` +
		`[[template "children" .Children]])`

	renderFuncCode = `
func [[if .ComName]](this *[[.ComName]])[[end]] VDOMRender() *vdom.Element {
	[[.Decls]]
	return [[.Return]]
}
`

	preludeCode = `package [[.Pkg]]

// THIS FILE IS AUTOGENERATED BY WADE.GO FUEL
// CHANGES WILL BE OVERWRITTEN
import (
[[if .DefaultImports]]
	"fmt"
	"github.com/gowade/wade/vdom"
	"github.com/gowade/wade"
[[end]]
[[range .Imports]]
	[[.Name]] "[[.Path]]"
[[end]]
)

func init() {
	_, _, _ = fmt.Printf, vdom.NewElement,  wade.Str
}
`

	comMethodsCode = `
[[ $receiver := .Receiver ]]

[[range .StateFields]]
	func (this [[$receiver]]) set[[.Name]](v [[.Type]]) {
		this.[[.Path]] = v
		this.rerender()
	}

	[[if eq .Type "bool"]]
	func (this [[$receiver]]) toggle[[.Name]]() {
		this.[[.Path]] = !this.[[.Path]]
	}
	[[end]]
[[end]]

func (this [[$receiver]]) VDOMChildren() []vdom.Node {
	return vdom.GetComponentData(this).Children
}

func (this [[$receiver]]) rerender() {
	vdom.Rerender(this)
}
`

	refsCode = `
type [[.TypeName]] struct {
[[range .Fields]]
	[[.Name]] [[.Type]]
[[end]]
}

func (this *[[.ComName]]) Refs() [[.TypeName]] {
	return this.Com.InternalRefsHolder.([[.TypeName]])
}`

	comCreateCode = `&vdom.Element{
	Component: func(old vdom.Component) vdom.Component {
		var com *[[.ComType]]
		var ok bool
		if old != nil {
			com, ok = old.(*[[.ComType]])
		}
		if old == nil || !ok {
			com = &[[.ComType]]{}
		}
		
		cdata := vdom.CreateComponentData(com, old)

	[[range .FieldsAss]]
		com.[[.Name]] = [[.Value]]
	[[end]]
		[[.Decls]]

		cdata.Children = [[template "children" .ChildrenCode]]
		return com
	},
}`

	comDefCode = `
	type [[.ComName]] struct {}
	`
)

func newTpl(name string, code string) *template.Template {
	return template.Must(gTpl.New(name).Parse(code))
}

var (
	funcMap = template.FuncMap{
		"lastIdx": func(l []*bytes.Buffer) int {
			return len(l) - 1
		},
	}
	gTpl            = template.New("root").Delims("[[", "]]").Funcs(funcMap)
	childrenVDOMTpl = newTpl("children", childrenVDOMCode)
	textNodeVDOMTpl = newTpl("txvdom", textNodeVDOMCode)
	elementVDOMTpl  = newTpl("elvdom", elementVDOMCode)
	renderFuncTpl   = newTpl("renderFunc", renderFuncCode)
	preludeTpl      = newTpl("prelude", preludeCode)
	comMethodsTpl   = newTpl("comMethods", comMethodsCode)
	refsTpl         = newTpl("refs", refsCode)
	comCreateTpl    = newTpl("comCreate", comCreateCode)
	comDefTpl       = newTpl("comDef", comDefCode)
)

func newChildTpl(parent *template.Template, name, code string) *template.Template {
	return template.Must(parent.New(name).Parse(code))
}

func addChildTpl(parent *template.Template, name string, child *template.Template) *template.Template {
	return template.Must(parent.AddParseTree(name, child.Tree))
}
