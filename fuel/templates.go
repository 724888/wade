package main

import (
	"bytes"
	"fmt"
	"io"
	"text/template"
)

type (
	importTD struct {
		Path string
		Name string
	}

	preludeTD struct {
		Pkg     string
		Imports []importTD
	}

	stateFieldTD struct {
		Name, Type string
	}

	stateMethodsTD struct {
		Receiver, StateField, StateType string
		Setters                         []stateFieldTD
	}

	refFieldTD struct {
		Name, Type string
	}

	refsTD struct {
		ComName  string
		TypeName string
		Fields   []refFieldTD
	}

	fieldAssTD struct {
		Name, Value string
	}

	comCreateTD struct {
		Decls            *bytes.Buffer
		ComName, ComType string
		FieldsAss        []fieldAssTD

		ChildrenField string
		ChildrenCode  []*bytes.Buffer
	}

	comDefTD struct {
		ComName string
	}

	renderFuncTD struct {
		ComName string
		Return  *bytes.Buffer
		Decls   *bytes.Buffer
	}

	elementVDOMTD struct {
		Tag      string
		Key      string
		Attrs    map[string]string
		Children []*bytes.Buffer
	}

	textNodeVDOMTD struct {
		Text string
	}
)

const (
	childrenVDOMCode = `[[if .]]vdom.NewNodeList(
	[[$last := lastIdx .]]
	[[range $i, $c := .]]
	[[$c]][[if lt $i $last]],[[end]][[end]])[[else]]nil[[end]]`

	textNodeVDOMCode = `vdom.NewTextNode([[.Text]])`

	elementVDOMCode = `[[define "attrs"]]` +
		`[[if .Attrs]]` +
		`vdom.Attributes{` +
		`[[range $key, $value := .Attrs]]
			"[[$key]]": [[$value]],
		[[end]]` +
		`}[[else]]nil[[end]]` +
		`[[end]]` +
		`vdom.NewElement("[[.Tag]]", [[.Key]], [[template "attrs" .]],` +
		`[[template "children" .Children]])`

	renderFuncCode = `
func [[if .ComName]](this *[[.ComName]])[[end]] Render() *vdom.Element {
	[[.Decls]]
	return [[.Return]]
}
`

	preludeCode = `package [[.Pkg]]

// THIS FILE IS AUTOGENERATED BY WADE.GO FUEL
// CHANGES WILL BE OVERWRITTEN
import (
	"fmt"

	"github.com/gowade/wade/vdom"
	//"github.com/gowade/wade"
[[range .Imports]]
	[[.Path]][[.Name]]
[[end]]
)

func init() {
	_, _ = fmt.Printf, vdom.NewElement
}
`

	stateMethodsCode = `
[[ $receiver := .Receiver ]]
[[ $stateField := .StateField ]]

func (this [[$receiver]]) InternalInitState(stateData interface{}) {
	if stateData != nil {
		this.[[$stateField]] = stateData.(*[[.StateType]])
	} else {
		if this.[[$stateField]] == nil {
			var t [[.StateType]]
			this.[[$stateField]] = &t
		}
	}
}

[[range .Setters]]
func (this [[$receiver]]) set[[.Name]](v [[.Type]]) {
	this.[[$stateField]].[[.Name]] = v
	this.Rerender()
}
[[end]]
`

	refsCode = `
type [[.TypeName]] struct {
[[range .Fields]]
	[[.Name]] [[.Type]]
[[end]]
}

func (this *[[.ComName]]) Refs() [[.TypeName]] {
	return this.Com.InternalRefsHolder.([[.TypeName]])
}`

	rerenderMethodCode = `
func (this *%v) Rerender() {
}
`

	comCreateCode = `
(func() vdom.Node {
	com := &[[.ComType]]{}
[[range .FieldsAss]]
	com.[[.Name]] = [[.Value]]
[[end]]
	[[.Decls]]
[[if .ChildrenField]]
	com.[[.ChildrenField]] = [[template "children" .ChildrenCode]]
[[end]]

	return com
})()`

	comDefCode = `
	type [[.ComName]] struct {}
	`
)

func newTpl(name string, code string) *template.Template {
	return template.Must(gTpl.New(name).Parse(code))
}

var (
	funcMap = template.FuncMap{
		"lastIdx": func(l []*bytes.Buffer) int {
			return len(l) - 1
		},
	}
	gTpl            = template.New("root").Delims("[[", "]]").Funcs(funcMap)
	childrenVDOMTpl = newTpl("children", childrenVDOMCode)
	textNodeVDOMTpl = newTpl("txvdom", textNodeVDOMCode)
	elementVDOMTpl  = newTpl("elvdom", elementVDOMCode)
	renderFuncTpl   = newTpl("renderFunc", renderFuncCode)
	preludeTpl      = newTpl("prelude", preludeCode)
	stateMethodsTpl = newTpl("stateMethods", stateMethodsCode)
	refsTpl         = newTpl("refs", refsCode)
	comCreateTpl    = newTpl("comCreate", comCreateCode)
	comDefTpl       = newTpl("comDef", comDefCode)
)

func writeRerenderMethod(w io.Writer, comName string) {
	fmt.Fprintf(w, rerenderMethodCode, comName)
}

func newChildTpl(parent *template.Template, name, code string) *template.Template {
	return template.Must(parent.New(name).Parse(code))
}

func addChildTpl(parent *template.Template, name string, child *template.Template) *template.Template {
	return template.Must(parent.AddParseTree(name, child.Tree))
}
